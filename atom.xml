<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>过愙</title>
  
  <subtitle>编程有风险，入坑需谨慎</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zengwu.com.cn/"/>
  <updated>2021-11-21T09:19:51.716Z</updated>
  <id>https://zengwu.com.cn/</id>
  
  <author>
    <name>过客</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>curl发送POST请求</title>
    <link href="https://zengwu.com.cn/p/e334394.html"/>
    <id>https://zengwu.com.cn/p/e334394.html</id>
    <published>2021-11-19T03:40:55.000Z</published>
    <updated>2021-11-21T09:19:51.716Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>curl 是常用的命令行工具，用来请求 Web 服务器。它的名字就是客户端（client）的 URL 工具的意思。它的功能非常强大，命令行参数多达几十种。如果熟练的话，完全可以取代 Postman 这一类的图形界面工具。</p><h1 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h1><p>curl默认协议就是GET，直接使用 <code>curl url</code>相当于直接用浏览器打开。</p><h1 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h1><p>curl 使用 -X POST 可以发送POST消息。如果要post json数据，如：</p><pre><code class="line-numbers language-bash">curl -H &quot;Content-Type:application/json&quot; -X POST -d &#39;{&quot;uid&quot;:&quot;123&quot;}&#39; http://127.0.0.1:3000/rest/test</code></pre><p>参数解析：</p><ul><li>-H 请求头。post json需要添加 <code>-H &quot;Content-Type: application/json&quot;</code></li><li>-X 请求协议。</li><li>-d post的body内容，如果是json数据，外层再加一个<code>&#39;</code>包含</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;curl 是常用的命令行工具，用来请求 Web 服务器。它的名字就是客户端（client）的 URL 工具的意思。它的功能非常强大，命令行参
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://zengwu.com.cn/categories/Linux/"/>
    
    
      <category term="CentOS" scheme="https://zengwu.com.cn/tags/CentOS/"/>
    
      <category term="Ubuntu" scheme="https://zengwu.com.cn/tags/Ubuntu/"/>
    
      <category term="Linux" scheme="https://zengwu.com.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Java中byte数组和String字符串相互转换</title>
    <link href="https://zengwu.com.cn/p/334d5fc9.html"/>
    <id>https://zengwu.com.cn/p/334d5fc9.html</id>
    <published>2021-11-18T04:31:55.000Z</published>
    <updated>2021-11-21T09:30:24.551Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、简单的转换"><a href="#一、简单的转换" class="headerlink" title="一、简单的转换"></a>一、简单的转换</h2><p>Java中String提供了byte数组和String字符串相互转换的方法。</p><pre><code class="line-numbers language-java">        String str = &quot;Hello World&quot;;        // String 转 byte数组        byte [] strByte = str.getBytes();        // byte数组转 String        String strString = new String(strByte);</code></pre><h2 id="二、带编码方式转换"><a href="#二、带编码方式转换" class="headerlink" title="二、带编码方式转换"></a>二、带编码方式转换</h2><p>带编码方式有二种方式</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><pre><code class="line-numbers language-java">        try{            String str = &quot;Hello World&quot;;            // String 转 byte数组            byte [] strByte = str.getBytes(&quot;utf-8&quot;);            // byte数组转 String            String strString = new String(strByte,&quot;utf-8&quot;);        } catch (UnsupportedEncodingException e){            e.printStackTrace();        }</code></pre><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><pre><code class="line-numbers language-java">        String str = &quot;Hello World&quot;;        // String 转 byte数组        byte [] strByte = str.getBytes(StandardCharsets.UTF_8);        // byte数组转 String        String strString = new String(strByte, StandardCharsets.UTF_8);</code></pre><p>方法一和方法二的区别是，方法一的转换方法会抛出<code>UnsupportedEncodingException</code>异常， 使用时需要加<code>try catch</code>。而方法二不会抛出异常，平时使用方法二比会比较方便哈。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、简单的转换&quot;&gt;&lt;a href=&quot;#一、简单的转换&quot; class=&quot;headerlink&quot; title=&quot;一、简单的转换&quot;&gt;&lt;/a&gt;一、简单的转换&lt;/h2&gt;&lt;p&gt;Java中String提供了byte数组和String字符串相互转换的方法。&lt;/p&gt;
&lt;pre&gt;&lt;c
      
    
    </summary>
    
    
      <category term="Java" scheme="https://zengwu.com.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="https://zengwu.com.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Excel公式中创建包含双引号字符串</title>
    <link href="https://zengwu.com.cn/p/38171cdb.html"/>
    <id>https://zengwu.com.cn/p/38171cdb.html</id>
    <published>2021-11-16T05:52:59.000Z</published>
    <updated>2021-11-21T09:19:51.720Z</updated>
    
    <content type="html"><![CDATA[<p>在Excel公式中，如果要用到字符串，一般会用双引号将字符串引起来。如：</p><pre><code class="line-numbers language-excel">=IF(A1&gt;0,&quot;真&quot;,&quot;假&quot;)</code></pre><p>如果<code>A1</code>大于0显示字符串<code>真</code>，否则显示为<code>假</code>字符串</p><p>但是，如果要显示的结果字符串中包含双引号呢，如A1大于0时要显示为 <code>&quot;A1&gt;0&quot;为真</code>，直接使用会报公式语法错误。这时我们可以用<code>CHAR(34)</code>来表示比引号<code>&quot;</code>，然后使用<code>&amp;</code>来连接字符串。此时公式为：</p><pre><code class="line-numbers language-excel">=IF(A1&gt;0,CHAR(34)&amp;&quot;A1&gt;0&quot;&amp;CHAR(34)&amp;&quot;为真&quot;,&quot;假&quot;)</code></pre><p><img src="//gitee.com/guoke3915/zw/raw/master/p/38171cdb/19826068-9b83e8f6654fd466.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Excel公式中，如果要用到字符串，一般会用双引号将字符串引起来。如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;line-numbers language-excel&quot;&gt;=IF(A1&amp;gt;0,&amp;quot;真&amp;quot;,&amp;quot;假&amp;quot;)&lt;/code&gt;&lt;/
      
    
    </summary>
    
    
      <category term="软件使用" scheme="https://zengwu.com.cn/categories/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"/>
    
    
      <category term="软件使用" scheme="https://zengwu.com.cn/tags/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Win10双蓝牙音频同步输出</title>
    <link href="https://zengwu.com.cn/p/c77f34b0.html"/>
    <id>https://zengwu.com.cn/p/c77f34b0.html</id>
    <published>2021-11-13T17:50:55.000Z</published>
    <updated>2021-11-21T09:19:51.717Z</updated>
    
    <content type="html"><![CDATA[<p>　　有些蓝牙音箱可以相互配对再连接电脑可以实现多蓝牙同步输出的效果，但是大多不同品牌的蓝牙音箱还是不能相互配对的，要实现双蓝牙音频同步输出则需要借助软件了。<br>　　这里推荐<a href="https://www.vb-audio.com" target="_blank" rel="noopener">voice meeter</a>，官网上有三个版本提供下载，分别是 voicemeeter、voicemeeter banana 和 voicemeeter potato，除了potato 其他两个版本完全免费，可以实现音频多轨道输出了。</p><h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><p>　　这里使用<a href="https://vb-audio.com/Voicemeeter/banana.htm" target="_blank" rel="noopener">banana</a>版本，先去官网下载最新版本</p><p><img src="//gitee.com/guoke3915/zw/raw/master/p/c77f34b0/19826068-32d6b285660afab4.png" alt></p><p>　　下载后直接运行exe，点右下角的Install就可以安装，安装好后可能需要重启电脑。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>1、 设置系统音频输出为 VoiceMeeter Input(VB-Audio VoiceMeeter VAIO)</p><p><img src="//gitee.com/guoke3915/zw/raw/master/p/c77f34b0/19826068-d3602d33d5cd75e5.png" alt></p><p>2、打开 <code>voicemeeterpro</code>默认安装路径在<code>C:\Program Files (x86)\VB\Voicemeeter\</code>。<br><img src="//gitee.com/guoke3915/zw/raw/master/p/c77f34b0/19826068-9c64700ecadf563e.png" alt></p><p>3、 voicemeeterpro默认支持3个硬件音轨输出。点击可以选择输出的硬件设备，选择对应的蓝牙音箱。</p><ul><li>A1：天猫精灵X1</li><li>A2：华为AM08蓝牙音箱</li><li>A3：HDMI显示器外接有线音箱</li></ul><p><img src="//gitee.com/guoke3915/zw/raw/master/p/c77f34b0/19826068-97ac445eac9e64e5.png" alt></p><p>4、调整延迟</p><p>前面设置好后电脑播发的声音会在选项的三个设备上同时播放了，但是由于蓝牙设备的不同以及距离等问题，会出现不同的延迟，这里我们可以去设置里调整每个设备的延迟时间，这个根据个人听边自己调整了，调到一个自己听起来比较舒服的同步就行了。</p><p><img src="//gitee.com/guoke3915/zw/raw/master/p/c77f34b0/19826068-5cf564d8d193b0bc.png" alt></p><p>5、开机启动Banana并且常驻状态栏</p><p><img src="//gitee.com/guoke3915/zw/raw/master/p/c77f34b0/19826068-c0fd4e92e799c234.png" alt></p><p>额外分享一个<a href="https://www.bilibili.com/read/cv5380467" target="_blank" rel="noopener">voice meeter 详细教程</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　有些蓝牙音箱可以相互配对再连接电脑可以实现多蓝牙同步输出的效果，但是大多不同品牌的蓝牙音箱还是不能相互配对的，要实现双蓝牙音频同步输出则需要借助软件了。&lt;br&gt;　　这里推荐&lt;a href=&quot;https://www.vb-audio.com&quot; target=&quot;_blank
      
    
    </summary>
    
    
      <category term="Windows" scheme="https://zengwu.com.cn/categories/Windows/"/>
    
    
      <category term="软件使用" scheme="https://zengwu.com.cn/tags/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"/>
    
      <category term="Window" scheme="https://zengwu.com.cn/tags/Window/"/>
    
  </entry>
  
  <entry>
    <title>程序猿的情书</title>
    <link href="https://zengwu.com.cn/p/13fa19f4.html"/>
    <id>https://zengwu.com.cn/p/13fa19f4.html</id>
    <published>2021-11-11T03:11:11.000Z</published>
    <updated>2021-11-21T09:19:51.721Z</updated>
    
    <content type="html"><![CDATA[<p>亲爱的“对象”<br>　　我能抽象出整个世界，但是我不能抽象出你，因为你在我心中是那么的具体，所以我的世界并不完整。<br>　　我可以重载甚至覆盖这个世界里的任何一种方法，但是我却不能重载对你的思念，也许命中注定了，你在我的世界里永远的烙上了静态的属性。<br>　　而我不慎调用了爱你这个方法，当我义无返顾的把自己作为参数传进这个方法时，我才发现爱上你是一个死循环。。。<br>　　它不停的返回对你的思念压入我心里的堆栈，在这无尽的黑夜中，我的内存里已经再也装不下别人。。。<br>　　我不停的向系统申请空间，但却捕获一个异常：我爱的人不爱我。<br>　　为了解决这个异常，我愿意虚拟出最后一点内存，把所有我能实现的方法地址压入堆栈，并且在栈尾压入最后一个方法：将字符串“我爱你，你爱我吗？”传递给你。。。<br>　　如果返回值为真，我将用尽一生去爱你，否则，我将释放掉所有系统资源。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;亲爱的“对象”&lt;br&gt;　　我能抽象出整个世界，但是我不能抽象出你，因为你在我心中是那么的具体，所以我的世界并不完整。&lt;br&gt;　　我可以重载甚至覆盖这个世界里的任何一种方法，但是我却不能重载对你的思念，也许命中注定了，你在我的世界里永远的烙上了静态的属性。&lt;br&gt;　　而我不慎
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://zengwu.com.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="https://zengwu.com.cn/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>ssh端口映射</title>
    <link href="https://zengwu.com.cn/p/f5ce4608.html"/>
    <id>https://zengwu.com.cn/p/f5ce4608.html</id>
    <published>2021-11-08T00:55:55.000Z</published>
    <updated>2021-11-21T09:19:51.715Z</updated>
    
    <content type="html"><![CDATA[<p>考虑到在程序中使用ssh认证连接MongoDB数据库的问题，还折腾了<a href="https://www.jianshu.com/p/8a5a1f581f04" target="_blank" rel="noopener">《Java使用SSH连接MongoDB》</a>、<a href="https://www.jianshu.com/p/ac98c90833d0" target="_blank" rel="noopener">《C#使用SSH认证连接MongoDB》</a>、<a href="https://www.jianshu.com/p/e3617a2883ea" target="_blank" rel="noopener">《go中使用SSH认证连接MongoDB》</a>。后面发现，在linux中<code>ssh -L</code>命令的可以直接完成ssh认证并将远程端口映射成本地端口。然后再然程序连接本地对应的端口就可以了。</p><pre><code class="line-numbers language-bash">ssh -CfNgL bind_port:host:hostport  user@ip -o TCPKeepAlive=yes</code></pre><p>解析：</p><ul><li>-C        压缩传输数据</li><li>-f        建立SSH连接后放置后台，静默模式</li><li>-N        不要执行远程命令。 这对于仅转发端口很有用（仅限协议版本2）</li><li>-g        允许远程主机连接本地端口转发</li><li>-L        指定本地（客户端）主机上的给定端口要转发到远程端的给定主机和端口。</li><li>bind_port： 本地监听端口</li><li>host:hostport： 远程映射地址和端口</li><li>user@ip: ssh服务器ip和登录用户</li><li>-o TCPKeepAlive=yes：tcp连接保持</li></ul><p>例如：</p><pre><code class="line-numbers language-bash">ssh -CfNgL 3717:127.0.0.1:27017 192.168.0.105 -o TCPKeepAlive=yes# 使用可以查看ssh进程ps -ef | grep sshroot     27059     1  0 20:10 ?        00:00:00 ssh -CfNgL 3717:127.0.0.1:27017 192.168.0.105 -o TCPKeepAlive=yes</code></pre><p>然后，用mongodb连接 127.0.0.1:3717就可以了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;考虑到在程序中使用ssh认证连接MongoDB数据库的问题，还折腾了&lt;a href=&quot;https://www.jianshu.com/p/8a5a1f581f04&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《Java使用SSH连接MongoDB》&lt;/a
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://zengwu.com.cn/categories/Linux/"/>
    
    
      <category term="CentOS" scheme="https://zengwu.com.cn/tags/CentOS/"/>
    
      <category term="Ubuntu" scheme="https://zengwu.com.cn/tags/Ubuntu/"/>
    
      <category term="Linux" scheme="https://zengwu.com.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>go中使用SSH认证连接MongoDB</title>
    <link href="https://zengwu.com.cn/p/f0aeed1a.html"/>
    <id>https://zengwu.com.cn/p/f0aeed1a.html</id>
    <published>2021-11-07T11:25:55.000Z</published>
    <updated>2021-11-21T09:19:51.718Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、说明"><a href="#一、说明" class="headerlink" title="一、说明"></a>一、说明</h1><p>go连接MongoDB驱动库<code>mongo-driver</code>和<code>mgo.v2</code>库中都不支持ssh认证连接的。但是我们可以使用net库先与MongoDB数据库服务器建立ssh连接，然后再将MongoDB数据库所在服务器端口映射到本地连接中转发就可以了。</p><h1 id="二、使用"><a href="#二、使用" class="headerlink" title="二、使用"></a>二、使用</h1><p>下面以<code>mongo-driver</code>数据库驱动为例。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code class="line-numbers language-bash">go get -u github.com/zngw/sshtunnel</code></pre><p>实现代码</p><pre><code class="line-numbers language-bash">// @Title // @Description $// @Author  55// @Date  2021/11/7package mainimport (    &quot;context&quot;    &quot;github.com/zngw/log&quot;    &quot;github.com/zngw/sshtunnel/ssht&quot;    &quot;go.mongodb.org/mongo-driver/bson&quot;    &quot;go.mongodb.org/mongo-driver/mongo&quot;    &quot;go.mongodb.org/mongo-driver/mongo/options&quot;    &quot;go.mongodb.org/mongo-driver/mongo/readpref&quot;    &quot;net/url&quot;    &quot;strings&quot;    &quot;time&quot;)func main() {    sshUri := &quot;ssh://root:123456@192.168.1.55:22&quot;    mdbUri := &quot;mongodb://root:123456@127.0.0.1:27017/admin&quot;    u, err := url.Parse(mdbUri)    if err != nil {        log.Error(&quot;test&quot;, &quot;解析数据库连接信息失败 %v&quot;, err)        return    }    listen, err := ssht.TunnelUri(sshUri, u.Host, &quot;:3717&quot;)    if err != nil {        log.Error(&quot;test&quot;, &quot;启用ssh端口映射失败 %v&quot;, err)    } else {        log.Info(&quot;test&quot;, &quot;启用ssh端口映射成功 %s&quot;, listen)    }    // 替换数据库地址端口    mdbUri = strings.Replace(mdbUri, u.Host, listen, -1)    // 下面按正常逻辑连接mongodb    name := &quot;Test&quot;    maxTime := time.Duration(2)     // 链接超时时间    table := &quot;test&quot;                 // 表名    // 连接数据库    db, err := ConnectToDB(mdbUri, name, maxTime)    if err != nil {        log.Error(&quot;test&quot;,&quot;链接数据库有误!&quot;)    }    // 获取test表数据数量    collection := db.Collection(table)    count, err := collection.CountDocuments(context.Background(), bson.D{})    if err != nil {        log.Error(&quot;test&quot;, err.Error())        return    }    log.Info(&quot;test&quot;,&quot;collection.CountDocuments: %v&quot;, count)}func ConnectToDB(uri, name string, timeout time.Duration) (*mongo.Database, error)  {    // 设置连接超时时间    ctx, cancel := context.WithTimeout(context.Background(), timeout)    defer cancel()    // 通过传进来的uri连接相关的配置    o := options.Client().ApplyURI(uri)    // 发起链接    client, err := mongo.Connect(ctx, o)    if err != nil {        log.Error(&quot;test&quot;,err.Error())        return nil, err    }    // 判断服务是不是可用    if err = client.Ping(context.Background(), readpref.Primary()); err != nil {        log.Error(&quot;test&quot;,err.Error())        return nil, err    }    // 返回 client    return client.Database(name), nil}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、说明&quot;&gt;&lt;a href=&quot;#一、说明&quot; class=&quot;headerlink&quot; title=&quot;一、说明&quot;&gt;&lt;/a&gt;一、说明&lt;/h1&gt;&lt;p&gt;go连接MongoDB驱动库&lt;code&gt;mongo-driver&lt;/code&gt;和&lt;code&gt;mgo.v2&lt;/code&gt;库中都
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://zengwu.com.cn/categories/Golang/"/>
    
    
      <category term="Golang" scheme="https://zengwu.com.cn/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>C#使用SSH认证连接MongoDB</title>
    <link href="https://zengwu.com.cn/p/9c31a311.html"/>
    <id>https://zengwu.com.cn/p/9c31a311.html</id>
    <published>2021-11-05T13:42:57.000Z</published>
    <updated>2021-11-21T09:19:51.711Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、环境"><a href="#一、环境" class="headerlink" title="一、环境"></a>一、环境</h1><p>在C#中可以使用<code>Renci.SshNet</code>和<code>MongoDB.Driver</code>通过SSH认证连接MongoDB数据库。</p><p>先去NuGet程序包管理页面中，下载<code>Renci.SshNet</code>和<code>MongoDB.Driver</code>库</p><p><img src="https://upload-images.jianshu.io/upload_images/19826068-fad2048930d348b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h1 id="二、使用"><a href="#二、使用" class="headerlink" title="二、使用"></a>二、使用</h1><p>可以先通过SshNet库使用SSH认证连接MongoDB所在的服务器，再用MongoDB.Driver连接本地SshNet达到通过SSH认证连接MongoDB的目的。</p><p>实现代码</p><pre><code class="line-numbers language-C#">using System;using System.Collections.Generic;using MongoDB.Driver;using Renci.SshNet;public class MongoAdmin{    // 数据库连接参数    private const string MONGODB_URI = &quot;mongodb://root:123456@127.0.0.1:3717/admin&quot;;    private const string SSH_USER = &quot;root&quot;;          // ssh账号    private const string SSH_PASSWORD = &quot;.&quot;;         // ssh密码，若使用密钥且没密码时填空    private const string SSH_PRVKEY = &quot;./ssh.pem&quot;;   // ssh密钥，若使用密码登录时为空    private const string SSH_HOST = &quot;192.168.0.105&quot;; // ssh服务器    private const int    SSH_PORT = 22;              // ssh端口    public static void Test()    {        try        {            var uri = new Uri(MONGODB_URI);            // 存在密钥文件使用密钥登录，不存在密钥文件使用密码登录            ConnectionInfo conn = null;            if (string.IsNullOrEmpty(SSH_PRVKEY))            {                conn = new ConnectionInfo(SSH_HOST, SSH_PORT, SSH_USER, new PasswordAuthenticationMethod(SSH_USER, SSH_PASSWORD));            }            else            {                conn = new ConnectionInfo(SSH_HOST, SSH_PORT, SSH_USER, new PrivateKeyAuthenticationMethod(SSH_USER, new PrivateKeyFile(SSH_PRVKEY)));            }            // 连接SSH            var cli = new SshClient(conn);            cli.Connect();            var port = new ForwardedPortLocal(&quot;127.0.0.1&quot;, SSH_HOST, (uint)uri.Port);            cli.AddForwardedPort(port);            port.Start();            // 用本地端口替换mongodb uri中配置端口            var mUri = MONGODB_URI.Replace($&quot;:{uri.Port}&quot;, $&quot;:{port.BoundPort}&quot;);            var mCli = new MongoClient(mUri);            var mdb = mCli.GetDatabase(&quot;test&quot;);            foreach ( var name in mdb.ListCollectionNames().ToList())            {                Console.WriteLine(name);            }        }        catch(Exception e)        {            Console.WriteLine(e.ToString());        }    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、环境&quot;&gt;&lt;a href=&quot;#一、环境&quot; class=&quot;headerlink&quot; title=&quot;一、环境&quot;&gt;&lt;/a&gt;一、环境&lt;/h1&gt;&lt;p&gt;在C#中可以使用&lt;code&gt;Renci.SshNet&lt;/code&gt;和&lt;code&gt;MongoDB.Driver&lt;/code&gt;通
      
    
    </summary>
    
    
      <category term="CSharp(C#)" scheme="https://zengwu.com.cn/categories/CSharp-C/"/>
    
    
      <category term="CSharp(C#)" scheme="https://zengwu.com.cn/tags/CSharp-C/"/>
    
  </entry>
  
  <entry>
    <title>Java使用SSH连接MongoDB</title>
    <link href="https://zengwu.com.cn/p/a6b55fd5.html"/>
    <id>https://zengwu.com.cn/p/a6b55fd5.html</id>
    <published>2021-11-03T15:21:55.000Z</published>
    <updated>2021-11-21T09:19:51.714Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、环境"><a href="#一、环境" class="headerlink" title="一、环境"></a>一、环境</h1><p>在Java中可以使用<code>mongodb-driver</code>和<code>com.jcraft</code>来实现Java中使用SSH连接MongoDB。</p><p>maven配置</p><pre><code class="line-numbers language-xml">&lt;dependency&gt;    &lt;groupId&gt;org.mongodb&lt;/groupId&gt;    &lt;artifactId&gt;mongodb-driver&lt;/artifactId&gt;    &lt;version&gt;3.12.10&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.jcraft&lt;/groupId&gt;    &lt;artifactId&gt;jsch&lt;/artifactId&gt;    &lt;version&gt;0.1.55&lt;/version&gt;&lt;/dependency&gt;</code></pre><h1 id="二、使用"><a href="#二、使用" class="headerlink" title="二、使用"></a>二、使用</h1><p>可以先通过JSch库使用SSH连接到MongoDB所有的服务器，再设置经JSch从本地端口到远程MongoDB端口的转发，最后使用mongodb-driver连接本地的转发端口就可以连接服务器了。</p><p>实现代码</p><pre><code class="line-numbers language-java">package com.application;import com.jcraft.jsch.JSch;import com.jcraft.jsch.Session;import com.mongodb.*;import com.mongodb.client.MongoDatabase;import org.bson.codecs.configuration.CodecRegistries;import org.bson.codecs.configuration.CodecRegistry;import org.bson.codecs.pojo.PojoCodecProvider;import java.net.URI;public class MongoAdmin {    // 数据库连接参数    private static final String MONGODB_URI = &quot;mongodb://root:123456@127.0.0.1:3717/admin&quot;;    private static final String SSH_USER = &quot;root&quot;;          // ssh账号    private static final String SSH_PASSWORD = &quot;.&quot;;         // ssh密码，若使用密钥且没密码时填空    private static final String SSH_PRVKEY = &quot;./ssh.pem&quot;;   // ssh密钥，若使用密码登录时为空    private static final String SSH_HOST = &quot;192.168.0.105&quot;; // ssh服务器    private static final Integer SSH_PORT = 22;             // ssh端口    public static void test() {        try {            URI uri = new URI(MONGODB_URI);            java.util.Properties config = new java.util.Properties();            // 设置ssh自动接受新的公钥            config.put(&quot;StrictHostKeyChecking&quot;,&quot;no&quot;);            JSch jsch = new JSch();            // 设置ssh密钥            if (!&quot;&quot;.equals(SSH_PRVKEY)){                jsch.addIdentity(SSH_PRVKEY);            }            Session sshSession = jsch.getSession(SSH_USER, SSH_HOST, SSH_PORT);            if (!&quot;&quot;.equals(SSH_PASSWORD)){                sshSession.setPassword(SSH_PASSWORD);            }            sshSession.setConfig(config);            sshSession.connect();            // 设置端口转发，将远程MongoDB端口转发为本地MongoDB对应端口            sshSession.setPortForwardingL(uri.getPort(), uri.getHost(), uri.getPort());            // 创建MongoDB连接            PojoCodecProvider pojoCodecProvider =  PojoCodecProvider.builder().automatic(true).build();            CodecRegistry codecRegistry = CodecRegistries.fromRegistries(MongoClient.getDefaultCodecRegistry(),                    CodecRegistries.fromProviders(pojoCodecProvider));            MongoClientOptions.Builder optionsBuilder = MongoClientOptions.builder()                    .codecRegistry(codecRegistry).serverSelectionTimeout(1000);            MongoClientURI clientUri = new MongoClientURI(MONGODB_URI, optionsBuilder);            MongoClient mongoClient = new MongoClient(clientUri);            // 测试打印test库所有列表            MongoDatabase mdb = mongoClient.getDatabase(&quot;test&quot;);            for ( String name : mdb.listCollectionNames()){                System.out.println(name);            }        } catch (Exception e) {            System.out.println(e.toString());        }    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、环境&quot;&gt;&lt;a href=&quot;#一、环境&quot; class=&quot;headerlink&quot; title=&quot;一、环境&quot;&gt;&lt;/a&gt;一、环境&lt;/h1&gt;&lt;p&gt;在Java中可以使用&lt;code&gt;mongodb-driver&lt;/code&gt;和&lt;code&gt;com.jcraft&lt;/code&gt;来
      
    
    </summary>
    
    
      <category term="Java" scheme="https://zengwu.com.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="https://zengwu.com.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>也谈“过客”</title>
    <link href="https://zengwu.com.cn/p/58e1b8b4.html"/>
    <id>https://zengwu.com.cn/p/58e1b8b4.html</id>
    <published>2021-11-02T10:13:24.000Z</published>
    <updated>2021-11-02T14:25:46.253Z</updated>
    
    <content type="html"><![CDATA[<p>　　曾经用了十多年的网名“过客”，但自己很少去深思这个词的含义。昨天一个网友留言道：每个人都是自己生命中的主角，而不只是过客。也许是每个人的生活以及对这个词的理解都不同吧…<br>　　“过客”这个词在词典里解释为过路的人，在百度百科网络词汇中，过客：指在互联网上历来都是“客”源不断,从博客、威客、换客、维客、拼客、晒客和晾客后,现在竟然又冒出了过客这一新生网友群体。过客是指在网友在网络行走过程中，所浏览过的网页或网站，匆匆而过，称作“过客”。<br>　　就我的理解，所谓“过客”，便是匆匆走过的人。走过你的生活，进过你的心灵，深入过你的生命。“过客”在生活中应该一直是有的，只是以前很少有人说这个话题。随着现代文明的发展，信息的传播越来越广泛，越来越疾速，空间上的跨越也越来越方便，多元化的机会，让人与人的相遇，心灵与心灵的碰撞变得更容易了些。但这样的相遇与碰撞却还是受生活和空间的限制，于是，走近，远去，下一个走近，又无奈的远去，这样的聚聚分分不断的的产生，“过客”也就出现了。<br>　　所谓“过客”，匆匆的走过我们的生命，给生命留下一些痕迹，然后就像远飘的云彩，再顺着他们自己生命的方向悠然的离去？<br>　　徐志摩的《偶然》中也提到过这样的段，也许能更好的解释“过客”的涵义吧。“我是天空里一片云，偶尔把风影在你的波心——你不必讶异，更无须欢喜——在转瞬间消灭了踪影。你和相逢在黑夜的海上，你有你的，我有我的，方向；你记得也好，最好你忘掉，在这交会时互放的光亮！”生命与全命的相逢，就是这样偶然而难以把握，交汇时互映光辉，然后就是擦肩而过，留下记忆或遗忘。对“过客”，天长地久是无法强加的奢望。<br>　　以乎很伤感，似乎很无奈，但生命在很多时候就是这样的无助。相对于浩瀚的宇宙和无限的时空，地球就是一个匆匆的过客，而渺小的人类相对于地球，便又成了一个匆匆的过客，在漫漫的人类发展史上，每一个人是一个匆匆的过客，在一人长长的一生中，那些匆匆而来又匆匆而去的人又是我们生命中的过客。我们是过客里的过客，能选择什么，又能放弃什么？<br>　　坦然的接受这生命中聚聚分分吧，没有讶异，也不要抱怨。来了接受；去了，坦然。别人进出我们的心灵，我们也出进别人的生命，别人是你的过客，你也是别人匆匆的过客。无需奢求，只静静的享受拥有时的那份感动。同时感谢，感谢他们曾走入我们的生命…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　曾经用了十多年的网名“过客”，但自己很少去深思这个词的含义。昨天一个网友留言道：每个人都是自己生命中的主角，而不只是过客。也许是每个人的生活以及对这个词的理解都不同吧…&lt;br&gt;　　“过客”这个词在词典里解释为过路的人，在百度百科网络词汇中，过客：指在互联网上历来都是“客
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://zengwu.com.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="https://zengwu.com.cn/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Linux下读写NTFS格式</title>
    <link href="https://zengwu.com.cn/p/536760e1.html"/>
    <id>https://zengwu.com.cn/p/536760e1.html</id>
    <published>2021-10-31T16:05:43.000Z</published>
    <updated>2021-11-02T14:25:46.238Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h1><p>在Linux上可以使用NTFS-3G来挂载NTFS格式的硬盘。NTFS-3G 是一个开源的软件，可以实现Linux、Free BSD、Mac OSX、NetBSD 和Haiku 等操作系统中的NTFS 读写支持。  它可以安全且快速地读写Windows 系统的NTFS 分区，而不用担心数据丢失。</p><h1 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h1><p>Ubuntu系统默认是自带ntfs-3g的，在CentOS中可以使用<code>yum</code>命令直接安装</p><pre><code class="line-numbers language-bash">yum install -y ntfs-3g</code></pre><h1 id="三、使用"><a href="#三、使用" class="headerlink" title="三、使用"></a>三、使用</h1><p>先用<code>fdisk -l</code>查看需要挂载硬盘的盘符。例如为<code>/dev/sdb</code></p><pre><code class="line-numbers language-bash">mount -t ntfs-3g /dev/sdb /data</code></pre><h1 id="四、设置开机自动挂载"><a href="#四、设置开机自动挂载" class="headerlink" title="四、设置开机自动挂载"></a>四、设置开机自动挂载</h1><p>打开<code>/etc/fstab</code>文件，在最后添加</p><pre><code class="line-numbers language-bash"># 只读模式挂载/dev/sdb /data ntfs-3g ro,umask=0222,defaults 0 0# 读写模式挂载/dev/sdb /data ntfs-3g rw,umask=0000,defaults 0 0</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、介绍&quot;&gt;&lt;a href=&quot;#一、介绍&quot; class=&quot;headerlink&quot; title=&quot;一、介绍&quot;&gt;&lt;/a&gt;一、介绍&lt;/h1&gt;&lt;p&gt;在Linux上可以使用NTFS-3G来挂载NTFS格式的硬盘。NTFS-3G 是一个开源的软件，可以实现Linux、Free
      
    
    </summary>
    
    
      <category term="Ubuntu" scheme="https://zengwu.com.cn/categories/Ubuntu/"/>
    
    
      <category term="CentOS" scheme="https://zengwu.com.cn/tags/CentOS/"/>
    
      <category term="Ubuntu" scheme="https://zengwu.com.cn/tags/Ubuntu/"/>
    
      <category term="Linux" scheme="https://zengwu.com.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>股市中的过客</title>
    <link href="https://zengwu.com.cn/p/874c58c2.html"/>
    <id>https://zengwu.com.cn/p/874c58c2.html</id>
    <published>2021-10-30T13:39:00.000Z</published>
    <updated>2021-11-02T14:25:46.230Z</updated>
    
    <content type="html"><![CDATA[<p>　　工作十多年，手里有点小积蓄，之前存银行放余额宝发现利息都赶不上物价上涨。怎么样才能不亏呢？<br>　　在四五月份的时候开始买基金，那时候白酒消费比较凶残，各平台推荐的也比较多，对于小白来说看着推荐的还长了，也就跟风进了一些白酒消费类和上证50指数基金，结果到七八月份的时候亏了10%左右。本想赚点零花钱的，结果别人把碗给端走了。<br>　　自己的钱要掌握在自己手里，于是在八月底的时候开始爬进了股市。最近上班也不算太忙，手机也可以看看行情，也不太会去追热点做短线，买了些医疗、新能源、光伏相关的股票，摸爬滚打了二个月，小赚了11.4%，把基金亏的赚了回来。<br><img src="//gitee.com/guoke3915/zw/raw/master/p/874c58c2/19826068-8f317eecb6b95b22.png" alt></p><p>　　当然，入市有风险，不能把所有的鸡蛋放一个篮子，合理分配是比较重要的。我是把小积蓄分成了10份，3份存银行定期、3份买基金（虽然现在比较坑还亏着，但相信长期会有赚的）、3份玩股票、最后留1份在余额宝当流动资金。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　工作十多年，手里有点小积蓄，之前存银行放余额宝发现利息都赶不上物价上涨。怎么样才能不亏呢？&lt;br&gt;　　在四五月份的时候开始买基金，那时候白酒消费比较凶残，各平台推荐的也比较多，对于小白来说看着推荐的还长了，也就跟风进了一些白酒消费类和上证50指数基金，结果到七八月份的时
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://zengwu.com.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="https://zengwu.com.cn/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>go读取docx文档</title>
    <link href="https://zengwu.com.cn/p/c66a286f.html"/>
    <id>https://zengwu.com.cn/p/c66a286f.html</id>
    <published>2021-10-29T14:47:31.000Z</published>
    <updated>2021-11-02T14:25:46.235Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>docx 是一个带有 xml 的 zip 文件,  <a href="https://github.com/srinathh/gooxml" target="_blank" rel="noopener">srinathh/gooxml</a> 是一个用于创建 Office Open XML 文档的库.这个库只支持office 2007以及之后的版本的文档,即只能读取<code>.docx、.xlsx 和 .pptx</code>,面不能读取<code>.doc、.xls 和 .ppt</code></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><pre><code class="line-numbers language-bash">go get baliance.com/gooxml/document</code></pre><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>解析docx文档代码</p><pre><code class="line-numbers language-go">package mainimport (    &quot;baliance.com/gooxml/document&quot;    &quot;fmt&quot;    &quot;log&quot;)func main() {    doc, err := document.Open(&quot;zngw.docx&quot;)    if err != nil {        log.Fatalf(&quot;error opening document: %s&quot;, err)    }    //doc.Paragraphs()得到包含文档所有的段落的切片    for i, para := range doc.Paragraphs() {        //run为每个段落相同格式的文字组成的片段        fmt.Println(&quot;-----------第&quot;, i, &quot;段-------------&quot;)        for j, run := range para.Runs() {            fmt.Print(&quot;\t-----------第&quot;, j, &quot;格式片段-------------&quot;)            fmt.Print(run.Text())        }        fmt.Println()    }}</code></pre><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>如有以下文档,有一个标题, 第二行是一段文字, 第三行有二种字体.</p><p><img src="//gitee.com/guoke3915/zw/raw/master/p/c66a286f/19826068-138e2a2e271824de.png" alt></p><p>代码读取的结果为:</p><pre><code class="line-numbers language-bash">-----------第 0 段-------------    -----------第0格式片段-------------这里是标题-----------第 1 段-------------    -----------第0格式片段-------------这里是docx测试文档-----------第 2 段------------------------第 3 段-------------    -----------第0格式片段-------------Hello World!    -----------第1格式片段-------------你好呀</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;docx 是一个带有 xml 的 zip 文件,  &lt;a href=&quot;https://github.com/srinathh/gooxml&quot;
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://zengwu.com.cn/categories/Golang/"/>
    
    
      <category term="Golang" scheme="https://zengwu.com.cn/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 20.04 安装 Nats</title>
    <link href="https://zengwu.com.cn/p/4d81b25b.html"/>
    <id>https://zengwu.com.cn/p/4d81b25b.html</id>
    <published>2021-10-27T07:56:30.000Z</published>
    <updated>2021-11-02T14:25:46.241Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h1><p>nats是一个开源的，云原生的消息系统。核心基于EventMachine开发，原理是基于消息发布订阅机制，每台服务器上的每个模块会根据自己的消息类别向MessageBus发布多个消息主题，而同时也向自己需要交互的模块，按照需要的主题订阅消息。能够达到每秒8-11百万个消息，整个程序很小只有3M Docker image，它不支持持久化消息，如果你离线，你就不能获得消息。使用nats streaming可以做到持久化，缓存等功能。</p><h1 id="2、下载"><a href="#2、下载" class="headerlink" title="2、下载"></a>2、下载</h1><p>去<a href="https://github.com/nats-io" target="_blank" rel="noopener">https://github.com/nats-io</a>下载最新版本的nats-server版本。这里用<a href="https://github.com/nats-io/nats-server/releases/download/v2.6.2/nats-server-v2.6.2-linux-amd64.tar.gz" target="_blank" rel="noopener">2.6.2版本</a></p><h1 id="3、运行"><a href="#3、运行" class="headerlink" title="3、运行"></a>3、运行</h1><p>解压后直接运行<code>nats-server</code>就可以了</p><pre><code class="line-numbers language-bash">tar zxf nats-server-v2.6.2-linux-amd64.tar.gz./nats-server-v2.6.2-linux-amd64/nats-server</code></pre><h1 id="4、将nats添加为服务"><a href="#4、将nats添加为服务" class="headerlink" title="4、将nats添加为服务"></a>4、将nats添加为服务</h1><pre><code class="line-numbers language-ini">vim /lib/systemd/system/nats.service[Unit]Description=nats-server daemonAfter=syslog.target  network.targetWants=network.target[Service]ExecStart=/home/nats-server/nats-server -c /home/nats-server/nats.ymlRestart= on-failure[Install]WantedBy=multi-user.target</code></pre><p>然后就可以通过<code>systemctl</code>来启动停止了</p><pre><code class="line-numbers language-bash">#开机启动systemctl enable nats# 启动systemctl start nats# 停止systemctl stop nats# 查看状态systemctl status nats</code></pre><h1 id="5、启动参数配置说明"><a href="#5、启动参数配置说明" class="headerlink" title="5、启动参数配置说明"></a>5、启动参数配置说明</h1><p>在源码<a href="https://github.com/nats-io/nats-server/blob/main/main.go#L26-L81" target="_blank" rel="noopener">main.go</a>中可以看到配置参数。</p><pre><code class="line-numbers language-yml">服务器选项:    -a, --addr &lt;host&gt;                绑定主机IP地址（默认是0.0.0.0）    -p, --port &lt;port&gt;                客户端连接NATS服务器使用的端口（默认是4222）    -n, --name &lt;server_name&gt;         服务器名字(默认:自动)    -P, --pid &lt;file&gt;                 存储PID的文件    -m, --http_port &lt;port&gt;           HTTP监听端口    -ms,--https_port &lt;port&gt;          HTTPS监听端口    -c, --config &lt;file&gt;              指定配置文件    -t                               测试配置文并退出    -sl,--signal &lt;signal&gt;[=&lt;pid&gt;]    向 nats-server 进程发送信号（停止、退出、重新打开、重新加载）                                      &lt;pid&gt; 可以是 PID（例如 1）或 PID 文件的路径（例如 /var/run/nats-server.pid）        --client_advertise &lt;string&gt;  向其他服务器广播的客户端 URL日志选项:    -l, --log &lt;file&gt;                 指定日志输出的文件    -T, --logtime                    是否开启日志的时间戳（默认为true）    -s, --syslog                     启用syslog作为日志方法    -r, --remote_syslog &lt;addr&gt;       远程日志服务器的地址（默认为udp://localhost:514）    -D, --debug                      开启调试输出    -V, --trace                      跟踪原始的协议    -VV                              详细跟踪（也跟踪系统帐户）    -DV                              调试并跟踪    -DVV                             调试和详细跟踪（也跟踪系统帐户）JetStream 选项:    -js, --jetstream                 启用 JetStream 功能。    -sd, --store_dir &lt;dir&gt;           设置存储目录。授权认证选项:        --user &lt;user&gt;                连接需要的用户名        --pass &lt;password&gt;            连接需要的密码        --auth &lt;token&gt;               连接所需的授权令牌TLS 安全选项:        --tls                       启用TLS，不验证客户端（默认为false）        --tlscert &lt;file&gt;             服务器证书文件        --tlskey &lt;file&gt;              服务器证书私钥        --tlsverify                  启用TLS，每一个客户端都要认证        --tlscacert &lt;file&gt;           客户端证书CA用于认证集群选项:        --routes &lt;rurl-1, rurl-2&gt;    请求和连接的路由        --cluster &lt;cluster-url&gt;      请求路由的集群 URL        --cluster_name &lt;string&gt;      Cluster Name，如果不设置会动态生成一个        --no_advertise &lt;bool&gt;        不向客户端通告已知的集群信息        --cluster_advertise &lt;string&gt; 向其他服务器通告的集群 URL        --connect_retries &lt;number&gt;   连接重试次数常规选项:    -h, --help                       显示帮助消息    -v, --version                   显示版本信息        --help_tls                   显示TLS 帮助消息</code></pre><h1 id="6、配置文件"><a href="#6、配置文件" class="headerlink" title="6、配置文件"></a>6、配置文件</h1><p>使用参数启动难免太复杂了点，所以可以通过-c加配置文件来启动。</p><p>NATS服务器配置文件的格式比较灵活，结合了传统的JSON格式和新的YAML格式的风格。<br>NATS配置文件格式支持以下语法：</p><pre><code class="line-numbers language-yml">Mixed Arrays: […]Nested Maps: {…}Multiple comment types: # and //Key value assigments using:    Equals sign (foo = 2)    Colon (foo: 2)    Whitespace (foo 2)Maps can be assigned with no key separatorSemicolons as value terminators in key/value assignments are optional&lt;br&gt;</code></pre><h2 id="简单配置"><a href="#简单配置" class="headerlink" title="简单配置"></a>简单配置</h2><pre><code class="line-numbers language-yml">listen: 127.0.0.1:4222</code></pre><h2 id="NATS服务器配置文件示例"><a href="#NATS服务器配置文件示例" class="headerlink" title="NATS服务器配置文件示例"></a>NATS服务器配置文件示例</h2><pre><code class="line-numbers language-yml">port: 4242   # 供客户端连接的监听端口net: apcera.me # 监听的网络地址http_port: 8222 # HTTP监控端口# 客户端连接的认证信息authorization { user:   derek password: T0pS3cr3t timeout: 1}# 集群定义cluster { host: &#39;127.0.0.1&#39; # 主机地址 port: 4244     # 路由连接的入站(inbound)端口 # 路由连接的认证信息 authorization {  user: route_user  password: T0pS3cr3tT00!  timeout: 0.5 } # Routes are actively solicited and connected to from this server. # Other servers can connect to us if they supply the correct credentials # in their routes definitions from above. routes = [  nats-route://user1:pass1@127.0.0.1:4245  nats-route://user2:pass2@127.0.0.1:4246 ]}# 日志选项debug:  falsetrace:  truelogtime: falselog_file: &quot;/tmp/gnatsd.log&quot;# PID进程文件pid_file: &quot;/tmp/gnatsd.pid&quot;# 一些系统属性# 客户端最大连接数max_connections: 100# 最大协议控制行max_control_line: 512# 最大的有效负载max_payload: 65536# 慢消费者阀值max_pending_size: 10000000</code></pre><p>配置文件参考：<a href="http://article.nxpop.com/col/6304.html" target="_blank" rel="noopener">http://article.nxpop.com/col/6304.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1、介绍&quot;&gt;&lt;a href=&quot;#1、介绍&quot; class=&quot;headerlink&quot; title=&quot;1、介绍&quot;&gt;&lt;/a&gt;1、介绍&lt;/h1&gt;&lt;p&gt;nats是一个开源的，云原生的消息系统。核心基于EventMachine开发，原理是基于消息发布订阅机制，每台服务器上的每个
      
    
    </summary>
    
    
      <category term="Ubuntu" scheme="https://zengwu.com.cn/categories/Ubuntu/"/>
    
    
      <category term="Ubuntu" scheme="https://zengwu.com.cn/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>go中国家新闻出版署实名认证</title>
    <link href="https://zengwu.com.cn/p/c01f879d.html"/>
    <id>https://zengwu.com.cn/p/c01f879d.html</id>
    <published>2021-10-25T07:27:37.000Z</published>
    <updated>2021-11-02T14:25:46.234Z</updated>
    
    <content type="html"><![CDATA[<p>随着网络游戏防沉迷系统的接入，实名认证验证也是一个必不可少的部分，网上有第三方的实名认证但基本上都收费，<a href="http://www.nppa.gov.cn/" target="_blank" rel="noopener">国家新闻出版署</a>提供了免费的接口，不过需要自己去提交申请，获取<code>应用标识 (APPID)</code>、<code>应用密钥 (Secret Key)</code>、<code>业务权限标识(BizId)</code>，并将请求服务器的IP设为白名单后，就可以调用<code>https:// api.wlc.nppa.gov.cn/idcard/authentication/check</code>接口来获取实名认真了。</p><p>这个接口中请求体body使用了AES-128/GCM + BASE64算法加密，签名使用了sha256。直接上完整的代码</p><pre><code class="line-numbers language-go">import (    &quot;bytes&quot;    &quot;crypto/aes&quot;    &quot;crypto/cipher&quot;    &quot;crypto/rand&quot;    &quot;crypto/sha256&quot;    &quot;encoding/base64&quot;    &quot;encoding/hex&quot;    &quot;encoding/json&quot;    &quot;fmt&quot;    &quot;io&quot;    &quot;io/ioutil&quot;    &quot;net/http&quot;    &quot;sort&quot;    &quot;strconv&quot;    &quot;time&quot;)// 国家新闻出版署配置信息type nppaInfo struct {    AppId     string // 应用标识    SecretKey string // 应用密钥    BizId     string // 业务权限标识}var nppa nppaInfo// 输入国家新闻出版署配置信息func NppaInit(appId, secretKey, bizId string) {    nppa = nppaInfo{        AppId:     appId,        SecretKey: secretKey,        BizId:     bizId,    }}// 实名验证// ai     - 游戏内部成员标识,固定32位字符，一般使用 md5(用户ID)// name - 实名信息中的姓名// id     - 实名信息中身份证号码// 返回//         - result 是否验证成功//         - errcode 状态码//         - errmsg 状态描述func NppaCheck(ai, name, id string) (result bool, errcode int, errmsg string ) {    client := &amp;http.Client{}    // body 参数    param := map[string]string{        &quot;ai&quot;:    ai,        &quot;name&quot;:  name,        &quot;idNum&quot;: id,    }    // AES-128/GCM + BASE64算法加密    jsonParam, _ := json.Marshal(param)    cipher, _ := gcmEncrypt(string(jsonParam))    body, _ := json.Marshal(map[string]string{        &quot;data&quot;: cipher,    })    // post请求地址    req, _ := http.NewRequest(&quot;POST&quot;, &quot;https://api.wlc.nppa.gov.cn/idcard/authentication/check&quot;, bytes.NewReader(body))    // header头验证信息    headers := map[string]string{        &quot;appId&quot;:      nppa.AppId,        &quot;bizId&quot;:      nppa.BizId,        &quot;timestamps&quot;: strconv.FormatInt(time.Now().UnixNano()/1e6, 10),    }    // 签名    headers[&quot;sign&quot;] = sign(headers, string(body))    headers[&quot;Content-Type&quot;] = &quot;application/json;charset=utf-8&quot;    for k, v := range headers {        req.Header.Set(k, v)    }    // 请求    resp, err := client.Do(req)    if err != nil {        return false, -1, &quot;Http请求错误&quot;    }    defer resp.Body.Close()    if resp.StatusCode != 200 {        return false, resp.StatusCode, &quot;Http请求返回码错误&quot;    }    str, err := ioutil.ReadAll(resp.Body)    if err != nil {        return false, -2, &quot;Http请求返回数据为空&quot;    }    var msg map[string]interface{}    err = json.Unmarshal(str, &amp;msg)    if err != nil {        return false, -3, &quot;Http请求返回数据格式错误&quot;    }    ec, ok := msg[&quot;errcode&quot;]    if !ok {        return false, -3, &quot;Http请求返回数据格式错误&quot;    }    errcode = int(ec.(float64))    if errcode != 0 {        errmsg, _:= msg[&quot;errmsg&quot;]        return false, errcode, errmsg.(string)    }    data, ok := msg[&quot;data&quot;]    if !ok {        return false, -3, &quot;Http请求返回数据格式错误&quot;    }    r, ok := data.(map[string]interface{})[&quot;result&quot;]    if !ok {        return false, -3, &quot;Http请求返回数据格式错误&quot;    }    status, ok := r.(map[string]interface{})[&quot;status&quot;]    if !ok {        return false, -3, &quot;Http请求返回数据格式错误&quot;    }    errcode = int(status.(float64))    if errcode == 0{        return true, 0, &quot;认证成功&quot;    } else if errcode == 1 {        return false, errcode, &quot;认证中&quot;    }else {        return false, errcode, &quot;认证失败&quot;    }}func gcmEncrypt(originalText string) (string, error) {    // 需要解码    key, _ := hex.DecodeString(nppa.SecretKey)    block, err := aes.NewCipher(key)    if err != nil {        return &quot;&quot;, err    }    aesGcm, err := cipher.NewGCM(block)    if err != nil {        return &quot;&quot;, err    }    // 向量    nonce := make([]byte, aesGcm.NonceSize())    if _, err := io.ReadFull(rand.Reader, nonce); err != nil {        return &quot;&quot;, err    }    cipherText := aesGcm.Seal(nonce, nonce, []byte(originalText), nil)    // encode as base64 string    encoded := base64.StdEncoding.EncodeToString(cipherText)    return encoded, nil}func sign(headers map[string]string, body string) string {    var data string    var keys []string    // key排序    for k := range headers {        keys = append(keys, k)    }    sort.Strings(keys)    // 拼接    for _, k := range keys {        data = data + k + headers[k]    }    data = nppa.SecretKey + data + body    // 对字符串进行sha256哈希    h := sha256.New()    h.Write([]byte(data))    sum := h.Sum(nil)    return hex.EncodeToString(sum)}</code></pre><p>调用</p><pre><code class="line-numbers language-go">func main() {    // 初始化    NppaInit(&quot;test-appId&quot;,&quot;2836e95fcd10e04b0069bb1ee659955b&quot;,&quot;test-bizId&quot;)    // 使用    userId := &quot;123456&quot;    name := &quot;岑吾&quot;    id := &quot;xxxxxxxxxxxxxxxxxx&quot;    h := md5.New()    h.Write([]byte(userId))    ok,code,msg := NppaCheck(hex.EncodeToString(h.Sum(nil)), name, id)    fmt.Println(ok,code,msg)}</code></pre><p>详细返回参数可见<a href="https://www.aliyundrive.com/s/cfVduHgQ3Fb" target="_blank" rel="noopener">网络游戏防沉迷实名认证系统</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;随着网络游戏防沉迷系统的接入，实名认证验证也是一个必不可少的部分，网上有第三方的实名认证但基本上都收费，&lt;a href=&quot;http://www.nppa.gov.cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;国家新闻出版署&lt;/a&gt;提供了免费的接口，
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://zengwu.com.cn/categories/Golang/"/>
    
    
      <category term="Golang" scheme="https://zengwu.com.cn/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 20.04 安装 Redis</title>
    <link href="https://zengwu.com.cn/p/618372ba.html"/>
    <id>https://zengwu.com.cn/p/618372ba.html</id>
    <published>2021-10-24T05:27:42.000Z</published>
    <updated>2021-11-02T14:25:46.243Z</updated>
    
    <content type="html"><![CDATA[<p>在 Ubuntu 20.04 上安装 Redis 可以下载<code>http://download.redis.io/redis-stable.tar.gz</code>直接运行，但也可以使用<code>apt</code>来直接按装。Ubuntu 20.04 软件源中有Redis 5.0。</p><pre><code class="line-numbers language-bash">sudo apt updatesudo apt install redis-server</code></pre><h2 id="启动、停止、重启"><a href="#启动、停止、重启" class="headerlink" title="启动、停止、重启"></a>启动、停止、重启</h2><p>安装完成后Redis会自动启动，可以用<code>systemctl</code>来控制Redis的启动、停止、重启等</p><pre><code class="line-numbers language-bash"># 查看状态systemctl status redis-server.service# 启动systemctl start redis-server.service# 停止systemctl stop redis-server.service# 重启systemctl restart redis-server.service# 设置开机启动systemctl enable redis-server.service</code></pre><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p><code>apt</code>安装的Redis配置文件在<code>/etc/redis/redis.conf</code></p><h3 id="配置远程访问"><a href="#配置远程访问" class="headerlink" title="配置远程访问"></a>配置远程访问</h3><p>注释 bind这一行</p><pre><code class="line-numbers language-conf">#bind 127.0.0.1</code></pre><h3 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h3><pre><code class="line-numbers language-conf">requirepass 密码</code></pre><h3 id="修改端口"><a href="#修改端口" class="headerlink" title="修改端口"></a>修改端口</h3><pre><code class="line-numbers language-conf">port 6379</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在 Ubuntu 20.04 上安装 Redis 可以下载&lt;code&gt;http://download.redis.io/redis-stable.tar.gz&lt;/code&gt;直接运行，但也可以使用&lt;code&gt;apt&lt;/code&gt;来直接按装。Ubuntu 20.04 软件源中有
      
    
    </summary>
    
    
      <category term="Ubuntu" scheme="https://zengwu.com.cn/categories/Ubuntu/"/>
    
    
      <category term="Ubuntu" scheme="https://zengwu.com.cn/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 20.04安装Docker</title>
    <link href="https://zengwu.com.cn/p/35ea3f99.html"/>
    <id>https://zengwu.com.cn/p/35ea3f99.html</id>
    <published>2021-10-22T01:33:54.000Z</published>
    <updated>2021-11-02T14:25:46.240Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、卸载旧版本"><a href="#一、卸载旧版本" class="headerlink" title="一、卸载旧版本"></a>一、卸载旧版本</h2><pre><code class="line-numbers language-bash">sudo apt-get remove docker docker-engine docker.io containerd runc</code></pre><h2 id="二、使用官方安装脚本中的阿里云镜像自动安装"><a href="#二、使用官方安装脚本中的阿里云镜像自动安装" class="headerlink" title="二、使用官方安装脚本中的阿里云镜像自动安装"></a>二、使用官方安装脚本中的阿里云镜像自动安装</h2><pre><code class="line-numbers language-bash">curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun</code></pre><h2 id="三、启动Docker"><a href="#三、启动Docker" class="headerlink" title="三、启动Docker"></a>三、启动Docker</h2><pre><code class="line-numbers language-bash">sudo systemctl start docker</code></pre><h2 id="四、停止Docker"><a href="#四、停止Docker" class="headerlink" title="四、停止Docker"></a>四、停止Docker</h2><pre><code class="line-numbers language-bash">sudo systemctl stop docker.socket</code></pre><p>注意：停止时需要如果使用<code>sudo systemctl stop docker</code>是停止不了的，还会警告</p><pre><code class="line-numbers language-bash">root@ubuntu:~# systemctl stop dockerWarning: Stopping docker.service, but it can still be activated by:  docker.socket</code></pre><p>原因是Docker 有两个服务进程文件，可以通过<code>cd /lib/systemd/system/ &amp;&amp; ll|grep docker</code>查看，分别是<code>docker.service unit file</code> 和 <code>docker.socket unit file</code>，上面的警告意味着如果你试图停止docker服务，但docker.socket unit file还处于激活状态。</p><h2 id="五、设置开机启动"><a href="#五、设置开机启动" class="headerlink" title="五、设置开机启动"></a>五、设置开机启动</h2><pre><code class="line-numbers language-bash">sudo systemctl enable docker</code></pre><h2 id="六、显示版本"><a href="#六、显示版本" class="headerlink" title="六、显示版本"></a>六、显示版本</h2><pre><code class="line-numbers language-bash">docker version</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、卸载旧版本&quot;&gt;&lt;a href=&quot;#一、卸载旧版本&quot; class=&quot;headerlink&quot; title=&quot;一、卸载旧版本&quot;&gt;&lt;/a&gt;一、卸载旧版本&lt;/h2&gt;&lt;pre&gt;&lt;code class=&quot;line-numbers language-bash&quot;&gt;sudo ap
      
    
    </summary>
    
    
      <category term="Ubuntu" scheme="https://zengwu.com.cn/categories/Ubuntu/"/>
    
    
      <category term="Ubuntu" scheme="https://zengwu.com.cn/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>Docker中pull microsoft/dotnet报错</title>
    <link href="https://zengwu.com.cn/p/cf0371b3.html"/>
    <id>https://zengwu.com.cn/p/cf0371b3.html</id>
    <published>2021-10-22T01:33:54.000Z</published>
    <updated>2021-11-02T14:25:46.237Z</updated>
    
    <content type="html"><![CDATA[<h2 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h2><p>今天在一台新的服务器中pull microsoft/dotnet的时候报错了</p><pre><code>docker: Error response from daemon: pull access denied for microsoft/dotnet, repository does not exist or may require &#39;docker login&#39;: denied: requested access to the resource is denied.</code></pre><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>这是因为.NET Core 2.1 和 2.2 容器映像已从 Docker Hub 中删除。 他们于 2021 年 8 月 21 日将这些映像移到了 Microsoft 容器注册表 (MCR)。 </p><p>使用<code>docker pull mcr.microsoft.com/dotnet/sdk:2.1</code> 来代替 <code>docker pull microsoft/dotnet</code>。</p><p>MCR 上的 .NET 映像可从以下存储库获得：</p><ul><li>mcr.microsoft.com/dotnet/runtime-deps</li><li>mcr.microsoft.com/dotnet/runtime</li><li>mcr.microsoft.com/dotnet/aspnet</li><li>mcr.microsoft.com/dotnet/sdk</li></ul><h2 id="具体的替换"><a href="#具体的替换" class="headerlink" title="具体的替换"></a>具体的替换</h2><h3 id="SDK"><a href="#SDK" class="headerlink" title="SDK"></a>SDK</h3><pre><code class="line-numbers language-txt">microsoft/dotnet:2.1-sdk -&gt; mcr.microsoft.com/dotnet/sdk:2.1microsoft/dotnet:2-sdk -&gt; mcr.microsoft.com/dotnet/sdk:2.1microsoft/dotnet:2.1-sdk-stretch -&gt; mcr.microsoft.com/dotnet/sdk:2.1-stretchmicrosoft/dotnet:2.1-sdk-stretch-arm32v7 -&gt; mcr.microsoft.com/dotnet/sdk:2.1-stretch-arm32v7microsoft/dotnet:2.1-sdk-nanoserver-1809 -&gt; mcr.microsoft.com/dotnet/sdk:2.1-nanoserver-1809microsoft/dotnet:2.1-sdk-alpine -&gt; mcr.microsoft.com/dotnet/sdk:2.1-alpinemicrosoft/dotnet:2.1-sdk-bionic -&gt; mcr.microsoft.com/dotnet/sdk:2.1-bionicmicrosoft/dotnet:2.1-sdk-bionic-arm32v7 -&gt; mcr.microsoft.com/dotnet/sdk:2.1-bionic-arm32v7microsoft/dotnet:latest -&gt; mcr.microsoft.com/dotnet/sdk:2.1</code></pre><h3 id="ASP-NET-Core"><a href="#ASP-NET-Core" class="headerlink" title="ASP.NET Core:"></a>ASP.NET Core:</h3><pre><code class="line-numbers language-txt">microsoft/dotnet:2.1-aspnetcore-runtime -&gt; mcr.microsoft.com/dotnet/aspnet:2.1microsoft/dotnet:2-aspnetcore-runtime-&gt; mcr.microsoft.com/dotnet/aspnet:2.1microsoft/dotnet:2.1-aspnetcore-runtime-stretch-slim -&gt; mcr.microsoft.com/dotnet/aspnet:2.1-stretch-slimmicrosoft/dotnet:2.1-aspnetcore-runtime-stretch-slim-arm32v7 -&gt; mcr.microsoft.com/dotnet/aspnet:2.1-stretch-slim-arm32v7microsoft/dotnet:2.1-aspnetcore-runtime-nanoserver-1809 -&gt; mcr.microsoft.com/dotnet/aspnet:2.1-nanoserver-1809microsoft/dotnet:2.1-aspnetcore-runtime-alpine -&gt; mcr.microsoft.com/dotnet/aspnet:2.1-alpinemicrosoft/dotnet:2.1-aspnetcore-runtime-bionic -&gt; mcr.microsoft.com/dotnet/aspnet:2.1-bionicmicrosoft/dotnet:2.1-aspnetcore-runtime-bionic-arm32v7 -&gt; mcr.microsoft.com/dotnet/aspnet:2.1-bionic-arm32v7microsoft/dotnet:aspnetcore-runtime-&gt; mcr.microsoft.com/dotnet/aspnet:2.1</code></pre><h3 id="NET-Runtime"><a href="#NET-Runtime" class="headerlink" title=".NET Runtime:"></a>.NET Runtime:</h3><pre><code class="line-numbers language-txt">microsoft/dotnet:2.1-runtime -&gt; mcr.microsoft.com/dotnet/runtime:2.1microsoft/dotnet:2-runtime -&gt; mcr.microsoft.com/dotnet/runtime:2.1microsoft/dotnet:2.1-runtime-stretch-slim -&gt; mcr.microsoft.com/dotnet/runtime:2.1-stretch-slimmicrosoft/dotnet:2.1-runtime-stretch-slim-arm32v7 -&gt; mcr.microsoft.com/dotnet/runtime:2.1-stretch-slim-arm32v7microsoft/dotnet:2.1-runtime-nanoserver-1809 -&gt; mcr.microsoft.com/dotnet/runtime:2.1-nanoserver-1809microsoft/dotnet:2.1-runtime-alpine -&gt; mcr.microsoft.com/dotnet/runtime:2.1-alpinemicrosoft/dotnet:2.1-runtime-bionic -&gt; mcr.microsoft.com/dotnet/runtime:2.1-bionicmicrosoft/dotnet:2.1-runtime-bionic-arm32v7 -&gt; mcr.microsoft.com/dotnet/runtime:2.1-bionic-arm32v7microsoft/dotnet:runtime -&gt; mcr.microsoft.com/dotnet/runtime:2.1</code></pre><h3 id="NET-Runtime-dependencies"><a href="#NET-Runtime-dependencies" class="headerlink" title=".NET Runtime dependencies:"></a>.NET Runtime dependencies:</h3><pre><code class="line-numbers language-txt">microsoft/dotnet:2.1-runtime-deps -&gt; mcr.microsoft.com/dotnet/runtime-deps:2.1microsoft/dotnet:2.1-runtime-deps-stretch-slim -&gt; mcr.microsoft.com/dotnet/runtime-deps:2.1-stretch-slimmicrosoft/dotnet:2.1-runtime-deps-stretch-slim-arm32v7 -&gt; mcr.microsoft.com/dotnet/runtime-deps:2.1-stretch-slim-arm32v7microsoft/dotnet:2.1-runtime-deps-alpine -&gt; mcr.microsoft.com/dotnet/runtime-deps:2.1-alpinemicrosoft/dotnet:2.1-runtime-deps-bionic -&gt; mcr.microsoft.com/dotnet/runtime-deps:2.1-bionicmicrosoft/dotnet:2.1-runtime-deps-bionic-arm32v7 -&gt; mcr.microsoft.com/dotnet/runtime-deps:2.1-bionic-arm32v7microsoft/dotnet:runtime-deps -&gt; mcr.microsoft.com/dotnet/runtime-deps:2.1</code></pre><p>详见dotnet/announcements 的github文档:<a href="https://github.com/dotnet/announcements/issues/197" target="_blank" rel="noopener">https://github.com/dotnet/announcements/issues/197</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;报错&quot;&gt;&lt;a href=&quot;#报错&quot; class=&quot;headerlink&quot; title=&quot;报错&quot;&gt;&lt;/a&gt;报错&lt;/h2&gt;&lt;p&gt;今天在一台新的服务器中pull microsoft/dotnet的时候报错了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker: Error re
      
    
    </summary>
    
    
      <category term="Ubuntu" scheme="https://zengwu.com.cn/categories/Ubuntu/"/>
    
    
      <category term="CentOS" scheme="https://zengwu.com.cn/tags/CentOS/"/>
    
      <category term="Ubuntu" scheme="https://zengwu.com.cn/tags/Ubuntu/"/>
    
      <category term="Linux" scheme="https://zengwu.com.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 20.04修改ip</title>
    <link href="https://zengwu.com.cn/p/f798f8e0.html"/>
    <id>https://zengwu.com.cn/p/f798f8e0.html</id>
    <published>2021-10-21T01:27:13.000Z</published>
    <updated>2021-11-02T14:25:46.239Z</updated>
    
    <content type="html"><![CDATA[<p>ubuntu从17.10开始，已放弃在/etc/network/interfaces里固定IP的配置，即使配置也不会生效，而是改成netplan方式 ，配置写在/etc/netplan/00-installer-config.yaml或者类似名称的yaml文件里</p><pre><code class="line-numbers language-bash">root@ubuntu:~# ls /etc/netplan/00-installer-config.yaml</code></pre><p>然后编辑 <strong>sudo vim /etc/netplan/00-installer-config.yaml</strong>文件修改ip配置。这是一个yml文件遵循yaml语法规则。具体配置如下：</p><pre><code class="line-numbers language-yml"># This is the network config written by &#39;subiquity&#39;network:  ethernets:    ens160:                            #配置的网卡的名称      addresses:      - 192.168.0.121/24               #配置的静态ip地址和掩码      dhcp4: no                        #关闭DHCP，如果需要打开DHCP则写yes      gateway4: 192.168.0.1            #网关地址      nameservers:        addresses:        - 192.168.0.1                  #DNS服务器地址，多个DNS服务器地址需要用英文逗号分隔开        search:        - localhost                    #本地域名解析  version: 2</code></pre><p>使配置的ip地址生效</p><pre><code class="line-numbers language-bash">sudo netplan apply</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ubuntu从17.10开始，已放弃在/etc/network/interfaces里固定IP的配置，即使配置也不会生效，而是改成netplan方式 ，配置写在/etc/netplan/00-installer-config.yaml或者类似名称的yaml文件里&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="Ubuntu" scheme="https://zengwu.com.cn/categories/Ubuntu/"/>
    
    
      <category term="Ubuntu" scheme="https://zengwu.com.cn/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 20.04修改ip</title>
    <link href="https://zengwu.com.cn/p/f798f8e0.html"/>
    <id>https://zengwu.com.cn/p/f798f8e0.html</id>
    <published>2021-10-18T16:31:55.000Z</published>
    <updated>2021-11-02T14:25:46.242Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用root账号本地登录"><a href="#使用root账号本地登录" class="headerlink" title="使用root账号本地登录"></a>使用root账号本地登录</h2><p>ubuntu系统默认root用户是不能登录的，密码也是空的。</p><p>如果要使用root用户登录，必须先为root用户设置密码</p><pre><code class="line-numbers language-bash">sudo passwd root</code></pre><p>先输入当前用户密码启动管理员权限，然后再输入二次root新密码。</p><h2 id="使用root账号ssh远程登录"><a href="#使用root账号ssh远程登录" class="headerlink" title="使用root账号ssh远程登录"></a>使用root账号ssh远程登录</h2><pre><code class="line-numbers language-bash">sudo vim /etc/ssh/sshd_config</code></pre><p>找到<code>PermitRootLogin</code>修改配置为<code>PermitRootLogin yes</code></p><p>重新ssh使修改配置生效</p><pre><code class="line-numbers language-bash">sudo  systemctl  restart  ssh</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;使用root账号本地登录&quot;&gt;&lt;a href=&quot;#使用root账号本地登录&quot; class=&quot;headerlink&quot; title=&quot;使用root账号本地登录&quot;&gt;&lt;/a&gt;使用root账号本地登录&lt;/h2&gt;&lt;p&gt;ubuntu系统默认root用户是不能登录的，密码也是空的。
      
    
    </summary>
    
    
      <category term="Ubuntu" scheme="https://zengwu.com.cn/categories/Ubuntu/"/>
    
    
      <category term="Ubuntu" scheme="https://zengwu.com.cn/tags/Ubuntu/"/>
    
  </entry>
  
</feed>
